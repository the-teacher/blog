### SOLID

Пять базовых принципов дизайна классов в ОО Проектировании

* **Single responsibility** - На каждый объект должна быть возложена одна единственная обязанность.
* **Open-closed** - Программные сущности должны быть открыты для расширения, но закрыты для изменения.
* **Liskov substitution** -  Подстановка. Объекты в программе могут быть заменены их наследниками без изменения свойств программы. (Контракты)
* **Interface segregation** - Разделение интерфейса. Много специализированных интерфейсов лучше, чем один универсальный.
* **Dependency inversion** - Инверсия зависимостей. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

### Объектный литерал

**Объектный литерал** - это способ описания объектов, с использованием пар ключ/значение внутри  фигурных скобок.

Объектный литерал не требует инстанцирования через **new**

Объектный литерал может быть расширен путем определения нового свойства следующим способом:

**myModule.newField = value;**

```coffeescript
  user =
    fname: 'John'
    lname: 'Smith'
    voice: -> "Hello people!"

  user.dance = -> "Move to the left, Move to the right"

  log user
  log user.voice()
  log user.dance()
```

### Функцинональный литерал

Способ опрделения функции. Функция создается анонимной и сохраняется в переменной

```coffeescript
summ = (a, b) -> a + b
```

Вызов функции объявленной таким образом до её объявления вызовет ошибку. Поскольку происходит обращение к не объявленной переменной.

```
f() // Ошибка исполнения
var f = function () {}
```

При обычном определении функции мы получаем undefined

```
f() // undefined
function f(){};
```

### Constructor

Конструктор - метод устанавливающий первоначальные значения в объект при его создании.

В JS почти все является объектом, вот почему у нас есть причина задуматься о конструкторах.

Есть 3 базовых способа создать объект:

```coffeescript
newObject = {}

newObject = new Object()

newObject = Object.create(null)
```

Есть 4 базовых способа установить/получить значение полей объекта:

Через точку

```coffeescript
newObject.someKey = "Hello World"
log newObject.someKey
```

Через квадратные скобки

```coffeescript
newObject['someKey'] = "Hello World"
log newObject['someKey']
```

Посредством метода defineProperty

https://kangax.github.io/es5-compat-table

```coffeescript
Object.defineProperty newObject, "someKey",
  value: "for more control of the property's behavior"
  writable: true
  enumerable: true
  configurable: true
```

Посредством метода defineProperties

```coffeescript
Object.defineProperties newObject,   
  "someKey": 
    value: "Hello World"
    writable: true 

  "anotherKey":
    value: "Foo bar"
    writable: false
```

JS не поддерживает классов, в нем есть спеиальные функции-конструкторы, которые работают с объектами.

Простым добавлением оператора new перед именем Функции мы момжем попросить JS вызвать специальную функцию, которая инстанцирует новый объект.

Внутри конструктора **this** обозначает создаваемый объект

```coffeescript
User = (fname = 'John' , lname = 'Smith', words = 'Yo Ho Ho!') ->
  @fname = fname
  @lname = lname
  @words = words
  @voice = -> @words    
  @

u = new User
log u
log u.voice()
```

Или так:

```
User = (@fname = 'John' , @lname = 'Smith', @words = 'Yo Ho Ho!') ->
  @voice = -> @words    
  @

u = new User
log u
log u.voice()
```

Обязательно возвращать из функции **@** (this), иначе CS вернет последнее выражение определенное внутри функции. А нам потребуется именно **this**

Здесь мы видим, что реализация наследования в JS может сопровождаться определенными трудностями.

Кроме того, общие методы будут определены для каждого нового объекта. Что не очень хорошо, поскольку общая функция должна быть определена на уровне класса, а не каждого объекта.

Однако, есть ряд альтернатив, которые помогут решить эти проблемы.
  
### Модуль

Модули это неотьемлимая часть всякой сложной и надежной системы. Они позволяют аккуратно организовать код.

Модули основаны на объектных литералах.

Шаблон модуль использует возвращение объектного литерала из определеющей функции.

Шаблон модуль появлися из попытки использовать в JS понятие публичных и частных методов класса.

Шаблон очень похож на немебленно вызываемую функцию, за исключением того, что возвращается не функция а объект.

Этот шаблон широко известен с 2003 года.

```coffeescript
  User = do ->
    fname = 'John'
    lname = 'Smith'
    voice = -> "Hello people!"

    fname: fname
    lname: lname
    voice: voice
    double_voice: -> [voice(), voice()].join ' '

  log User
  log User.fname
  log User.lname
  log User.voice
  log User.double_voice()
```

Импорт зависимости

```coffeescript
  User = do (JQ = $) ->
    fname = 'John'
    lname = 'Smith'
    voice = -> "Hello people!"
    select_body = -> JQ 'body'

    fname: fname
    lname: lname
    voice: voice
    double_voice: -> [voice(), voice()].join ' '
    select_body:  -> select_body()

  log User.select_body()
```

#### Плюсы

* Предоставляет открытое API для взаимодействия
* Ограничение области видимости функций, что уменшит вероятность конликта имен.
* Защита внутреннего функционала от внешнего воздействия.
* Легкое понимание и принятие программистами с опытом ООП.
* Позволяет исключить утечку переменных в глобальную область.

#### Минусы

* Мы не можем получить доступ к приватным методам при последующем расширения модуля.
* Нет возможности создать тесты для приватных методов
* Теряем гибкость при работе с приватными методами.

#### Хитрость 

* Для различных окружений можно вернуть различный набор API
* Отладка будет проще, если называть функции API теми же именами, что используются в защищенном разделе

### "Явный" модуль

В базовом случае интерфейсные функции определяются непосредственно в возвращаемом объекте.

Как вариант можно рассмотреть паттерн, в котором в возвращаемом объекте возвращаются ссылки на приватные методы.

```coffeescript
  User = do (JQ = $) ->
    fname = 'John'
    lname = 'Smith'
    voice = -> "Hello people!"
    select_body = -> JQ 'body'
    double_voice = -> [voice(), voice()].join ' '
      
    return {
      getBody:     select_body
      doubleVoice: double_voice
    }
```

Такой вариант значительно проще для чтения понимания, однако грозит сложностями переопределения функций. Поскольку все методы, которые вы бы хотели "подправить" по сути являются приватным.


### Singlton

Singleton — порождающий шаблон, гарантирующий что в однопоточном приложении будет единственный экземпляр класса с глобальной точкой доступа.


```coffeescript
superMan = do ->
  init = ->
    getRand = -> Math.random()

    return {
      fname: "Clark"
      lname: "Kent"
      uid:   getRand()
      getRand: -> getRand()
    }

  getInstance: -> @instance ?= init()
  
log superMan.getInstance().uid
log superMan.getInstance().getRand()
```

#### Плюсы

* Контролируемый доступ к единственному экземпляру.

#### Минусы

* Нарушение контроля. Синглтон нарушает SRP (Single Responsibility Principle) — контролирует кол-во объектов
* Сложность поддержки. Трудно отследить зависимость от синглтона. Вызывается внутри методов и обычно не передается в качестве аргумента. Скрытый публичный контракт.
* Глобальное состояние. Неявная зависимость подсистем. Мы не знаем текущее состояние объекта, кто и когда его менял, и это состояние может быть вовсе не таким, как ожидается. Корректность работы с синглтоном зависит от порядка обращений к нему.
* Снижение тестируемости. Вместо синглтона нельзя подпихнуть Mock-объект. Если синглтон имеет интерфейс для изменения своего состояния, то тесты начинают зависеть друг от друга.

#### Использование

* Должен быть ровно один экземпляр некоторого класса, легко доступный всем клиентам
* Единственный экземпляр должен расширяться путем порождения подклассов, и клиентам нужно иметь возможность работать с расширенным экземпляром без модификации своего кода. (?)
