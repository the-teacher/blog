### Объектный литерал

**Объектный литерал** - это способ описания объектов, с использованием пар ключ/значение внутри  фигурных скобок.

Объектный литерал не требует инстанцирования через **new*

Объектный литерал может быть расширен путем определения нового свойства следующим способом: **myModule.newField = value;**

```coffeescript
  user =
    fname: 'John'
    lname: 'Smith'
    voice: -> "Hello people!"

  user.dance = -> "Move to the left, Move to the right"

  log user
  log user.voice()
  log user.dance()
```

### Функцинональный литерал

Способ опрделения функции. Функция создается анонимной и сохраняется в переменной

```coffeescript
summ = (a, b) -> a + b
```

Вызов функции объявленной таким образом до её объявления вызовет ошибку. Поскольку происходит обращение к не объявленной переменной.

```
f() // Ошибка исполнения
var f = function () {}
```

При обычном определении функции мы получаем undefined

```
f() // undefined
function f(){};
```

foo ->


### Constructor

Конструктор - метод устанавливающий первоначальные значения в объект при его создании.

В JS почти все является объектом, вот почему у нас есть причина задуматься о конструкторах.

Есть 3 базовых способа создать объект:

```coffeescript
newObject = {}

newObject = new Object()

newObject = Object.create(null)
```

Есть 4 базовых способа установить/получить значение полей объекта:


### Singlton

Singleton — порождающий шаблон, гарантирующий что в однопоточном приложении будет единственный экземпляр класса с глобальной точкой доступа.

#### Плюсы

* Контролируемый доступ к единственному экземпляру.

#### Минусы

* Нарушение контроля. Синглтон нарушает SRP (Single Responsibility Principle) — контролирует кол-во объектов
* Сложность поддержки. Трудно отследить зависимость от синглтона. Вызывается внутри методов и обычно не передается в качестве аргумента. Скрытый публичный контракт.
* Глобальное состояние. Неявная зависимость подсистем. Мы не знаем текущее состояние объекта, кто и когда его менял, и это состояние может быть вовсе не таким, как ожидается. Корректность работы с синглтоном зависит от порядка обращений к нему.
* Снижение тестируемости. Вместо синглтона нельзя подпихнуть Mock-объект. Если синглтон имеет интерфейс для изменения своего состояния, то тесты начинают зависеть друг от друга.

#### Использование

* Должен быть ровно один экземпляр некоторого класса, легко доступный всем клиентам
* Единственный экземпляр должен расширяться путем порождения подклассов, и клиентам нужно иметь возможность работать с расширенным экземпляром без модификации своего кода. (?)

### Модуль

Модули это неотьемлимая часть всякой сложной и надежной системы. Они позволяют аккуратно организовать код.

Модули основаны на объектных литералах.

Шаблон модуль использует возвращение объектного литерала из определеющей функции.

Шаблон модуль появлися из попытки использовать в JS понятие публичных и частных методов класса.

Шаблон очень похож на немебленно вызываемую функцию, за исключением того, что возвращается не функция а объект.

Этот шаблон широко известен с 2003 года.

```coffeescript
  User = do ->
    fname = 'John'
    lname = 'Smith'
    voice = -> "Hello people!"

    fname: fname
    lname: lname
    voice: voice
    double_voice: -> [voice(), voice()].join ' '

  log User
  log User.fname
  log User.lname
  log User.voice
  log User.double_voice()
```

Имрпорт зависимости

```coffeescript
  User = do (JQ = $) ->
    fname = 'John'
    lname = 'Smith'
    voice = -> "Hello people!"
    select_body = -> JQ 'body'

    fname: fname
    lname: lname
    voice: voice
    double_voice: -> [voice(), voice()].join ' '
    select_body:  -> select_body()

  log User.select_body()
```

#### Плюсы

* Предоставляет открытое API для взаимодействия
* Ограничение области видимости функций, что уменшит вероятность конликта имен.
* Защита внутреннего функционала от внешнего воздействия.
* Легкое понимание и принятие программистами с опытом ООП.
* Позволяет исключить утечку переменных в глобальную область.

#### Минусы

* Мы не можем получить доступ к приватным методам при последующем расширения модуля.
* Нет возможности создать тесты для приватных методов
* Теряем гибкость при работе с приватными методами.

#### Хитрость 

* Для различных окружений можно вернуть различный набор API
* Отладка будет проще, если называть функции API теми же именами, что используются в защищенном разделе

